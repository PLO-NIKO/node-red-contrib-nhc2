<script type="text/html" data-template-name="nhc2-output">
  <div class="form-row">
    <label>Config</label>
    <select id="node-input-config"></select>
  </div>
  <div class="form-row">
    <label>Search</label>
    <input type="text" id="node-input-deviceFilter" placeholder="Type to filter devices…" style="width:100%">
  </div>
  <div class="form-row">
    <label>Device</label>
    <select id="node-input-deviceUuid"></select>
  </div>
  <input type="hidden" id="node-input-deviceName">
  <div class="form-row">
    <label>Property</label>
    <select id="node-input-property"></select>
  </div>
  <div class="form-row">
    <label>Definitions</label>
    <table id="node-input-propertyTable" style="width:100%;border-collapse:collapse">
      <thead>
        <tr>
          <th style="text-align:left">Property</th>
          <th style="text-align:left">HasStatus</th>
          <th style="text-align:left">CanControl</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</script>

<script>
RED.nodes.registerType('nhc2-output',{
  category: 'NHC2',
  defaults: {
    config:      { type:'nhc2-config', required:true },
    deviceUuid:  { value:'', required:true },
    deviceName:  { value:'' },
    property:    { value:'' }
  },
  inputs: 1, outputs: 2,
  icon: 'bridge.svg',
  label: function() {
    const name = this.deviceName || 'NHC2 Out';
    const prop = this.property || 'All';
    return `${name} [${prop}]`;
  },
  oneditprepare: function(){
    const rawRoot = RED.settings.httpAdminRoot;
    const p = window.location.pathname;
    const fallbackDir = p.substring(0, p.lastIndexOf('/'));
    let adminRoot = rawRoot && rawRoot !== '/' ? (rawRoot.endsWith('/') ? rawRoot : rawRoot + '/') : fallbackDir + '/';

    const me = this;
    let devices = [];

    const savedDeviceUuid = this.deviceUuid;
    const savedDeviceName = this.deviceName;
    const savedProperty   = this.property;

    console.log('[nhc2-output] oneditprepare: initial deviceUuid', savedDeviceUuid, 'property', savedProperty);

    function formatLabel(d){
      const loc = (d.Parameters.find(p=>p.LocationName)||{}).LocationName || '';
      return `${d.Name} (${d.Model} – ${d.Type} – ${loc})`;
    }

    function filterAndRender(){
      const filter = $('#node-input-deviceFilter').val().toLowerCase();
      const select = $('#node-input-deviceUuid').empty();

      const matches = devices.filter(d => formatLabel(d).toLowerCase().includes(filter));
      matches.forEach(d => {
        $('<option>').val(d.Uuid).text(formatLabel(d)).appendTo(select);
      });

      if (matches.length > 0) {
        // Always select first match
        select.val(matches[0].Uuid).trigger('change');
      }
    }

    function populateDevices(){
      const cid = $('#node-input-config').val();
      if (!cid) return;
      console.log('[nhc2-output] populateDevices: loading devices for config', cid);
      $.getJSON(adminRoot + 'nhc2-config/' + cid + '/devices').done(devsObj=>{
        devices = Object.values(devsObj);

        const select = $('#node-input-deviceUuid').empty();
        devices.forEach(d => {
          $('<option>').val(d.Uuid).text(formatLabel(d)).appendTo(select);
        });

        if (devices.find(d => d.Uuid === savedDeviceUuid)) {
          select.val(savedDeviceUuid);
        } else if (devices.length > 0) {
          select.prop("selectedIndex", 0);
        }

        select.trigger('change');
      });
    }

    function populateProperties(){
      const uuid = $('#node-input-deviceUuid').val();
      const dev = devices.find(d=>d.Uuid === uuid);
      if (!dev) return;

      $('#node-input-deviceName').val(dev.Name);
      const propSel = $('#node-input-property').empty();

      $('<option>').val('').text('All').appendTo(propSel);
      const defs = dev.PropertyDefinitions || [];
      defs.forEach(o=>{
        const name = Object.keys(o)[0];
        $('<option>').val(name).text(name).appendTo(propSel);
      });

      const exists = defs.some(o => Object.keys(o)[0] === savedProperty);
      if (exists || savedProperty === '') {
        propSel.val(savedProperty);
        console.log('[nhc2-output] populateProperties: restored property', savedProperty);
      } else {
        propSel.prop("selectedIndex", 0);
        console.log('[nhc2-output] populateProperties: property not found, defaulting to All');
      }

      const tb = $('#node-input-propertyTable tbody').empty();
      defs.forEach(o=>{
        const name = Object.keys(o)[0];
        const def  = o[name];
        $('<tr>')
          .append($('<td>').text(name))
          .append($('<td>').text(def.HasStatus))
          .append($('<td>').text(def.CanControl))
          .appendTo(tb);
      });
    }

    // Event handlers
    $('#node-input-config').on('change', populateDevices);
    $('#node-input-deviceFilter').on('input', filterAndRender);
    $('#node-input-deviceUuid').on('change', function() {
      me.deviceUuid = $(this).val();
      const selected = devices.find(d => d.Uuid === me.deviceUuid);
      me.deviceName = selected ? selected.Name : '';
      populateProperties();
    });
    $('#node-input-property').on('change', function() {
      me.property = $(this).val();
    });

    $('#node-input-config').val(this.config);
    $('#node-input-deviceFilter').val('');
    populateDevices();

    // ✅ Restore saved values if user cancels
    this._restoreOriginal = function() {
      this.deviceUuid  = savedDeviceUuid;
      this.deviceName  = savedDeviceName;
      this.property    = savedProperty;
      console.log('[nhc2-output] oneditcancel: restored previous values');
    };
  },
  oneditcancel: function() {
    if (typeof this._restoreOriginal === 'function') {
      this._restoreOriginal();
    }
  }
});
</script>
